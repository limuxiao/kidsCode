# 🎨 魔法药水店 2.0 - 完整改版方案

---

## 📋 改版目标

将魔法药水店从「简单的序列练习工具」升级为「全面的编程思维训练系统」，覆盖循环、条件、变量、函数等核心编程概念。

---

## 🆕 核心改进方案

### 一、新增指令系统

#### 1. 循环指令 (LOOP)

```typescript
// 新增 BlockType
'REPEAT' | 'REPEAT_UNTIL' | 'FOR_EACH'

// 使用示例
REPEAT(3) {
  ADD_STARDUST
  STIR
}
// 等价于重复3次：加星尘 → 搅拌
```

**游戏场景：**
- 顾客需求："我需要一瓶纯净的星尘药水，请加入3次星尘并每次都搅拌"
- 不用循环：需要6条指令
- 用循环：只需2条指令（REPEAT(3) + 嵌套块）

**教育价值：**
- ✅ 理解代码复用
- ✅ 学习嵌套结构
- ✅ 培养抽象思维

---

#### 2. 条件指令 (CONDITIONAL)

```typescript
// 新增 BlockType
'IF_CONTAINS' | 'IF_COLOR_IS' | 'IF_TEMPERATURE'

// 使用示例
ADD_STARDUST
IF_CONTAINS('STARDUST') {
  ADD_FLAME  // 只有锅里有星尘时才加熔岩
}
STIR
```

**游戏场景：**
- 顾客需求："如果药水中有星尘，请加入熔岩来激活它的能量"
- 挑战：需要根据当前药水状态做决策

**教育价值：**
- ✅ 引入 IF-THEN 逻辑
- ✅ 状态判断思维
- ✅ 依赖关系理解

---

#### 3. 变量系统 (VARIABLES)

```typescript
// 新增 BlockType
'SET_TEMPERATURE' | 'CHECK_COLOR' | 'MEASURE_MAGIC'

// 药水属性
interface PotionState {
  ingredients: string[];      // 原料列表
  color: string;              // 颜色（混合规则）
  temperature: number;        // 温度（影响效果）
  magicPower: number;         // 魔力值
  isStirred: boolean;         // 是否搅拌过
}
```

**游戏场景：**
- 顾客需求："我需要一瓶紫色的药水，魔力值至少50"
- 孩子需要：
  1. 知道星尘(蓝) + 熔岩(红) = 紫色
  2. 计算每种原料的魔力值
  3. 达到目标值

**教育价值：**
- ✅ 理解状态/属性概念
- ✅ 数值计算思维
- ✅ 目标导向的规划

---

#### 4. 函数抽象 (FUNCTIONS)

```typescript
// 新增功能：自定义配方
'CREATE_RECIPE' | 'USE_RECIPE'

// 使用示例
// 第一步：创建"基础魔力水"配方
CREATE_RECIPE('基础魔力水') {
  ADD_STARDUST
  ADD_HERB
  STIR
}

// 第二步：在复杂配方中调用
USE_RECIPE('基础魔力水')
ADD_FLAME
STIR
```

**游戏场景：**
- 顾客需求："给我一瓶高级治疗药水（需要先做基础药水，再加强化原料）"

**教育价值：**
- ✅ 代码模块化思维
- ✅ 函数调用概念
- ✅ DRY原则（Don't Repeat Yourself）

---

### 二、新增游戏机制

#### 1. 药水属性系统

**颜色混合规则：**
```
星尘(蓝) + 熔岩(红) = 紫色
星尘(蓝) + 草药(绿) = 青色
熔岩(红) + 草药(绿) = 黄色
紫色 + 草药(绿) = 棕色
...
```

**温度系统：**
```
- 加入熔岩 → 温度 +30°C
- 加入冰晶 → 温度 -20°C
- 搅拌 → 温度 -5°C
- 温度过高(>100°C) → 药水爆炸
- 温度过低(<0°C) → 药水冻结
```

**魔力值系统：**
```
- 星尘：+20魔力
- 熔岩：+15魔力
- 草药：+10魔力
- 搅拌：魔力 ×1.2（激活效果）
- 配方正确 → 额外奖励魔力
```

**视觉反馈：**
- 药水颜色实时变化
- 温度计显示当前温度
- 魔力值进度条
- 冒泡/发光效果（根据状态）

---

#### 2. 复杂订单系统

**订单类型分级：**

**Level 1 - 简单订单（保留原玩法）**
```
"给我一瓶星尘药水"
→ ADD_STARDUST → STIR
```

**Level 2 - 属性要求**
```
"我需要一瓶蓝色药水"
→ 需要理解：只加星尘 = 蓝色
```

**Level 3 - 数值要求**
```
"我需要魔力值达到50的药水"
→ 需要计算：星尘(20) + 熔岩(15) = 35，搅拌后 ×1.2 = 42
→ 需要再加一种原料
```

**Level 4 - 条件要求**
```
"如果药水是紫色，就加入草药来中和它"
→ 需要使用 IF_COLOR_IS('紫色') 条件块
```

**Level 5 - 循环要求**
```
"我需要一瓶浓缩药水，请重复加入星尘5次"
→ 需要使用 REPEAT(5) { ADD_STARDUST }
```

**Level 6 - 复合要求**
```
"我需要一瓶温度在50-70度之间、颜色为紫色、魔力值大于80的药水"
→ 需要综合运用：
   - 颜色计算（星尘+熔岩）
   - 温度控制（可能需要加冰晶降温）
   - 魔力优化（多次搅拌或加更多原料）
```

**Level 7 - 函数调用**
```
"我需要两份治疗药水（每份都是：草药×2 + 星尘 + 搅拌）"
→ 先定义配方，再调用2次
```

---

#### 3. 价格体系 💰

**金币系统：**
```typescript
interface EconomySystem {
  coins: number;              // 当前金币
  ingredientPrices: Map<IngredientType, number>;  // 原料价格
  orderReward: number;        // 完成订单奖励
  perfectBonus: number;       // 完美配方额外奖励
}

// 原料价格表
const INGREDIENT_PRICES = {
  STARDUST: 10,     // 星尘 - 基础原料
  FLAME: 15,        // 熔岩 - 稍贵
  HERB: 8,          // 草药 - 便宜
  SLIME: 12,        // 粘液 - 中等
  CRYSTAL: 20,      // 冰晶 - 昂贵
  RARE_ESSENCE: 50  // 稀有精华 - 极贵（高级关卡）
};
```

**价格机制设计：**

**1. 成本计算**
```
每次使用原料 → 扣除对应金币
搅拌操作 → 免费（但消耗时间）
加热/冷却 → 5金币（能源成本）
```

**2. 收益系统**
```
完成订单基础奖励：
- 简单订单：30金币
- 中等订单：60金币
- 困难订单：100金币
- 完美配方（最优解）：+50% 奖励
- 快速完成：+20% 奖励
```

**3. 利润优化挑战**
```
顾客A：蓝色药水，支付40金币
方案1：ADD_STARDUST(10金币) + STIR → 利润30金币
方案2：ADD_STARDUST(10) + ADD_CRYSTAL(20) + STIR → 利润10金币
→ 孩子需要思考：颜色相同但成本不同！
```

**4. 破产机制**
```
- 金币 < 0 → 订单失败，需要重来
- 连续3次破产 → 提示优化建议
- 教学："试试只用必要的原料"
```

**游戏场景示例：**

**场景1 - 预算限制：**
```
顾客："我需要紫色药水，但我只有25金币"

挑战：
- 星尘(10) + 熔岩(15) = 25金币（刚好）
- 但如果加错了需要重做 → 破产
- 引入成功率思考
```

**场景2 - 批量订单：**
```
顾客："我需要5瓶蓝色药水，总预算80金币"

策略思考：
- 每瓶用星尘(10) = 50金币 → 利润30
- 能否用循环优化成本？
- 能否共享某些步骤？
```

**场景3 - 高级材料：**
```
顾客："我要最强的药水，不限预算"

决策：
- 用稀有精华(50)能获得200%奖励
- 但失败风险高（见成功率系统）
- 风险收益权衡
```

**教育价值：**
- ✅ **资源管理思维**：有限资源下做最优决策
- ✅ **成本收益分析**：计算利润最大化
- ✅ **优化意识**：追求最少成本解决问题
- ✅ **风险评估**：平衡成本与成功率
- ✅ **数学应用**：加减法、百分比计算

---

#### 4. 成功率体系 🎲

**成功率机制：**
```typescript
interface SuccessRateSystem {
  baseSuccessRate: number;        // 基础成功率 (0-1)
  ingredientQuality: Map<string, number>;  // 原料品质影响
  temperatureStability: number;   // 温度稳定性
  stirTiming: number;            // 搅拌时机
  overallSuccessRate: number;    // 综合成功率
}
```

**影响因素：**

**1. 原料品质（可见）**
```
普通星尘：100% 成功率，10金币
优质星尘：100% 成功率，15金币，魔力+25%
劣质星尘：80% 成功率，5金币，可能失败
```

**2. 温度控制（隐性难度）**
```
理想温度范围：50-70°C → 100% 成功率
温度偏离：
- 40-49°C 或 71-80°C → 90% 成功率
- 30-39°C 或 81-90°C → 70% 成功率
- <30°C 或 >90°C → 50% 成功率
- <0°C 或 >100°C → 0% 成功率（必定失败）
```

**3. 搅拌时机**
```
立即搅拌（加入原料后马上）→ 100%
延迟搅拌（加入多种原料后）→ 95%
过度搅拌（搅拌超过3次）→ 85%
不搅拌 → 60%
```

**4. 配方复杂度**
```
简单配方（1-2种原料）→ 100%
中等配方（3-4种原料）→ 95%
复杂配方（5+种原料）→ 90%
极限配方（8+种原料）→ 80%
```

**失败结果：**
```
成功率检定失败时：
- 药水爆炸 💥 → 损失所有原料和金币
- 药水变质 🤢 → 颜色/属性错误，订单失败
- 部分成功 😐 → 效果减半，获得50%奖励
```

**视觉反馈：**
```
配方预览界面显示：
┌─────────────────────────────┐
│ 📊 配方分析                  │
├─────────────────────────────┤
│ 预计成本: 35金币             │
│ 预计收益: 60金币             │
│ 预计利润: 25金币             │
│                             │
│ ⚠️ 成功率: 85%               │
│   └─ 温度控制: -10%          │
│   └─ 原料品质: -5%           │
│                             │
│ 💡 建议: 加入冰晶降温         │
└─────────────────────────────┘
```

**游戏场景示例：**

**场景1 - 廉价方案的风险：**
```
顾客："我需要紫色药水"

方案A（保险）：
- 普通星尘(10) + 普通熔岩(15) = 25金币
- 成功率：100%
- 利润：40 - 25 = 15金币

方案B（冒险）：
- 劣质星尘(5) + 劣质熔岩(8) = 13金币
- 成功率：80% × 80% = 64%
- 成功利润：40 - 13 = 27金币
- 失败损失：-13金币
- 期望收益：27×0.64 + (-13)×0.36 = 12.6金币

教学：期望值计算，风险与收益权衡
```

**场景2 - 温度控制挑战：**
```
顾客："我需要高温药水（需要>80°C）"

挑战：
- 加入2次熔岩 → 温度90°C
- 成功率降至70%（高温不稳定）
- 需要精确控制：熔岩 + 冷却 + 熔岩？
- 或者：接受70%风险？
```

**场景3 - 复杂配方的陷阱：**
```
顾客："我需要彩虹药水（包含所有颜色原料）"

诱惑：
- 奖励很高（200金币）
- 但需要6种原料 → 成功率仅80%
- 成本60金币
- 期望收益：200×0.8 - 60 = 100金币
- vs 做3次简单订单稳定赚90金币？

教学：风险分散策略
```

**高级玩法 - 保险系统（可选）：**
```
支付额外10%成本 → 失败时返还50%损失
支付额外20%成本 → 失败时返还100%损失

决策：何时值得买保险？
```

**教育价值：**
- ✅ **概率思维**：理解成功率和期望值
- ✅ **风险管理**：评估风险与收益
- ✅ **决策能力**：在不确定性下做选择
- ✅ **实验精神**：从失败中学习优化
- ✅ **数学应用**：百分比、概率、期望值计算
- ✅ **现实模拟**：真实世界中很多事情有失败概率

---

#### 5. 关卡特殊机制

**限制挑战（引入优化思维）：**
```
- 指令数量限制："最多使用8条指令完成"
- 原料限制："只能使用2种原料"
- 时间限制："30秒内完成"（可选）
```

**随机事件：**
```
- "药材短缺"：某种原料本关不可用
- "魔法波动"：搅拌效果翻倍
- "顾客加急"：需要快速完成
```

**多顾客系统（批量处理）：**
```
顾客A：蓝色药水
顾客B：红色药水
顾客C：紫色药水

挑战：能否用一套指令满足所有人？
（需要使用循环 + 条件判断）
```

---

### 三、UI/UX 改进

#### 1. 可视化增强

**实时状态面板（增强版）：**
```
┌─────────────────────────────┐
│ 🧪 药水状态                  │
├─────────────────────────────┤
│ 颜色: [████] 紫色            │
│ 温度: [====    ] 65°C        │
│ 魔力: [======  ] 45/100      │
│ 原料: 星尘, 熔岩        │
└─────────────────────────┘
```

**执行动画升级：**
- 加入原料时的飞溅效果
- 颜色渐变动画
- 温度计上升/下降
- 魔力值闪烁增长
- 搅拌时的漩涡效果

**顾客表情反馈：**
- 期待 → 满意 😊 / 失望 😞
- 根据药水接近程度显示表情变化

**订单预览界面（新增）：**
```
┌─────────────────────────────────┐
│ 📜 顾客订单 #3                   │
├─────────────────────────────────┤
│ 需求: 紫色药水，魔力值≥50        │
│ 支付: 60 💰                      │
│ 时限: 无                         │
│                                 │
│ 💡 推荐方案:                     │
│   星尘(10💰) + 熔岩(15💰) + 搅拌   │
│   成本: 25💰 | 利润: 35💰         │
│   成功率: 100% ✅                 │
│                                 │
│ ⚡ 冒险方案:                     │
│   劣质星尘(5💰) + 劣质熔岩(8💰)    │
│   成本: 13💰 | 潜在利润: 47💰     │
│   成功率: 64% ⚠️                 │
│   期望收益: 12.6💰 (考虑失败风险) │
│                                 │
│ [开始制作] [查看配方库]          │
└─────────────────────────────────┘
```

**原料选择面板（新增）：**
```
┌──────────────────────────────────────┐
│ 🎒 原料库存                           │
├──────────────────────────────────────┤
│ ⭐ 星尘                               │
│   ├─ 普通品质: 10💰 | 成功率100%      │
│   ├─ 优质品质: 15💰 | 成功率100% | +25%魔力 │
│   └─ 劣质品质: 5💰  | 成功率80% ⚠️    │
│                                      │
│ 🔥 熔岩                               │
│   ├─ 普通品质: 15💰 | 成功率100%      │
│   ├─ 优质品质: 22💰 | 成功率100% | +30%温度 │
│   └─ 劣质品质: 8💰  | 成功率75% ⚠️    │
│                                      │
│ 🌿 草药                               │
│   ├─ 新鲜草药: 8💰  | 成功率100%      │
│   └─ 枯萎草药: 3💰  | 成功率70% ⚠️    │
│                                      │
│ 💎 冰晶 (稀有)                        │
│   └─ 纯净冰晶: 20💰 | 成功率100% | -20°C │
│                                      │
│ ✨ 稀有精华 (限量)                    │
│   └─ 仅剩 3个: 50💰 | 成功率90% | 超强效果 │
│                                      │
│ 💰 当前金币: 125                      │
└──────────────────────────────────────┘
```"

---

#### 2. 交互优化

**嵌套块可视化：**
```
┌─ REPEAT(3) ──────────┐
│  ┌─ ADD_STARDUST     │
│  └─ STIR             │
└──────────────────────┘
```

**参数调整器：**
- REPEAT 块有滑动条调整次数
- 温度设定有数字输入
- 颜色有色轮选择器

**提示系统：**
- 鼠标悬停显示指令效果
- 错误时高亮问题指令
- 建议系统："试试使用循环来简化代码？"

---

### 四、难度曲线设计

#### 关卡进度（25关示例 - 整合价格与成功率）

**第1-3关：基础序列（保持原样）**
- 简单配方，熟悉界面
- 无金币限制，100%成功率（新手保护）

**第4-6关：引入属性 + 💰初识价格**
- 关卡4："做一瓶蓝色药水" + 首次显示原料价格
- 关卡5："温度保持在50度" + 控制成本在30金币内
- 关卡6："魔力值达到30" + 利润最大化挑战（提供3种方案对比）

**第7-9关：引入循环 + 💰批量经济**
- 关卡7："重复加入星尘3次" + 学习批量采购降低成本
- 关卡8："持续搅拌直到魔力值>50" + 时间成本概念（每秒-1金币）
- 关卡9："批量制作2份相同药水" + 规模效应（第2份成本减半）

**第10-12关：引入条件 + 🎲初识风险**
- 关卡10："如果有星尘，就加熔岩" + 首次出现劣质原料（80%成功率）
- 关卡11："温度>80时加入冰晶" + 温度失控导致失败案例教学
- 关卡12："颜色不是紫色就继续加原料" + 品质选择：贵但稳定 vs 便宜但冒险

**第13-15关：复合挑战 + 💰🎲风险收益权衡**
- 关卡13：同时满足颜色+温度+魔力 + 预算限制50金币
  - 挑战：只用普通原料无法达标，必须选择1-2个优质原料
- 关卡14：指令数量限制 + 多种原料品质选择
  - 3星评价：保守方案（100%成功，低利润）
  - 5星评价：最优方案（95%成功，高利润）
- 关卡15：多顾客订单 + 金币池共享
  - 3个顾客，初始80金币
  - 失败一次影响后续订单资金
  - 教学：风险分散策略

**第16-18关：函数抽象 + 💰配方成本优化**
- 关卡16：定义"基础药水"配方 + 计算配方标准成本
- 关卡17：调用配方并扩展 + 边际成本概念（追加原料更便宜）
- 关卡18：组合多个配方 + 配方库管理（保存3个最优配方）

**第19-21关：高级风险管理 🎲**
- 关卡19：**保险系统引入**
  - 顾客要求复杂配方（成功率70%）
  - 可选：支付10金币购买保险（失败返还50%）
  - 决策：何时值得买保险？
  
- 关卡20：**期望值挑战**
  - 选项A：简单订单，利润20金币，成功率100%
  - 选项B：困难订单，利润60金币，成功率60%
  - 选项C：极限订单，利润120金币，成功率40%
  - 教学：计算期望收益，选择最优策略
  
- 关卡21：**连续订单风险**
  - 5个订单，金币池100
  - 每次失败：金币-30，剩余订单难度+10%
  - 每次成功：金币+40，剩余订单难度-5%
  - 教学：动态调整风险策略

**第22-23关：综合经济模拟 💰🎲**
- 关卡22：**市场波动**
  - 原料价格每3个订单随机变动±30%
  - 需要根据价格调整配方策略
  - 引入："等待"机制（跳过订单，等待价格下跌）
  
- 关卡23：**竞争模式**
  - 与NPC药剂师竞争（显示其成本和成功率）
  - 目标：利润超过NPC
  - 教学：效率优化和风险平衡

**第24-25关：终极大挑战 🏆**
- 关卡24：**开放式经营**
  - 10个随机订单，自由选择接单顺序
  - 目标：金币达到500（起始100）
  - 多种解法（保守、激进、平衡）
  - 追求：最少订单数完成目标
  
- 关卡25：**完美药剂师**
  - 使用所有学过的概念（循环、条件、函数、价格、风险）
  - 极限挑战：成功率85%的超级订单
  - 预算紧张（成本限制）
  - 时间压力（30秒）
  - 3种难度可选（普通/困难/大师）

---

### 五、技术实现要点

#### 1. 数据结构升级

```typescript
// 新的 BlockType 定义
type BlockType = 
  // 原有指令
  | 'ADD_STARDUST' | 'ADD_FLAME' | 'ADD_SLIME' 
  | 'ADD_HERB' | 'ADD_CRYSTAL' | 'STIR'
  // 新增：控制流
  | 'REPEAT' | 'REPEAT_UNTIL' | 'IF_CONTAINS' 
  | 'IF_COLOR_IS' | 'IF_TEMPERATURE'
  // 新增：函数
  | 'CREATE_RECIPE' | 'USE_RECIPE'
  // 新增：操作
  | 'SET_TEMPERATURE' | 'HEAT' | 'COOL';

// 增强的 CodeBlock 结构
interface CodeBlock {
  id: string;
  type: BlockType;
  value?: number | string;
  children?: CodeBlock[];      // 支持嵌套（循环、条件内的指令）
  condition?: ConditionType;   // 条件判断类型
  recipeName?: string;         // 配方名称
}

// 药水状态
interface PotionState {
  ingredients: IngredientType[];
  color: string;               // RGB 或预定义颜色
  temperature: number;         // 0-200°C
  magicPower: number;          // 0-200
  isStirred: boolean;
  explosionRisk: number;       // 爆炸风险 0-1
}

// 关卡配置升级
interface PotionLevelConfig {
  id: number;
  title: string;
  description: string;
  customerRequest: string;
  
  // 新增：目标条件
  targetConditions: {
    colorRequired?: string;
    temperatureRange?: [number, number];
    minMagicPower?: number;
    maxIngredients?: number;
    exactRecipe?: BlockType[];  // 兼容旧模式
  };
  
  // 新增：限制条件
  constraints?: {
    maxInstructions?: number;     // 指令数量限制
    forbiddenBlocks?: BlockType[]; // 禁用指令
    timeLimit?: number;           // 时间限制（秒）
  };
  
  availableBlocks: BlockType[];
  unlockedConcepts: string[];     // 已解锁的编程概念
  
  // 新增：经济系统配置
  economy?: {
    initialCoins: number;         // 初始金币
    orderReward: number;          // 订单基础奖励
    budgetLimit?: number;         // 预算限制
    enableInsurance?: boolean;    // 是否开放保险
  };
  
  // 新增：风险系统配置
  riskSystem?: {
    enableQualityChoice: boolean; // 是否允许选择原料品质
    showSuccessRate: boolean;     // 是否显示成功率
    penaltyOnFailure: number;     // 失败惩罚（金币）
  };
}

// 💰 价格系统数据结构
interface EconomySystem {
  coins: number;                           // 当前金币
  totalEarned: number;                     // 累计收益
  totalSpent: number;                      // 累计支出
  currentOrderCost: number;                // 本次订单成本
  insurancePurchased: boolean;             // 是否购买保险
  priceFluctuation: Map<IngredientType, number>;  // 价格波动系数
}

// 原料品质与价格
enum IngredientQuality {
  POOR = 'poor',       // 劣质
  NORMAL = 'normal',   // 普通
  PREMIUM = 'premium'  // 优质
}

interface IngredientInfo {
  type: IngredientType;
  quality: IngredientQuality;
  basePrice: number;           // 基础价格
  currentPrice: number;        // 当前价格（考虑波动）
  successRate: number;         // 品质影响成功率
  effectBonus: number;         // 效果加成（魔力、温度等）
  stockCount?: number;         // 库存数量（稀有原料）
}

// 原料价格表
const INGREDIENT_PRICES: Record<IngredientType, Record<IngredientQuality, number>> = {
  STARDUST: {
    poor: 5,
    normal: 10,
    premium: 15
  },
  FLAME: {
    poor: 8,
    normal: 15,
    premium: 22
  },
  HERB: {
    poor: 3,
    normal: 8,
    premium: 12
  },
  CRYSTAL: {
    poor: 12,
    normal: 20,
    premium: 30
  },
  // 新增：稀有原料
  RARE_ESSENCE: {
    normal: 50,    // 无劣质版本
    premium: 80
  }
};

// 🎲 成功率系统数据结构
interface SuccessRateSystem {
  baseRate: number;              // 基础成功率
  qualityModifier: number;       // 品质修正
  temperatureModifier: number;   // 温度修正
  stirTimingModifier: number;    // 搅拌时机修正
  complexityModifier: number;    // 复杂度修正
  overallRate: number;           // 综合成功率
  riskLevel: 'low' | 'medium' | 'high';  // 风险等级
}

// 成功率计算因子
interface SuccessRateFactors {
  ingredientQuality: number;     // 0.7-1.0（劣质到优质）
  temperatureControl: number;    // 0.5-1.0（温度偏离度）
  stirTiming: number;            // 0.6-1.0（搅拌是否及时）
  recipeComplexity: number;      // 0.8-1.0（配方复杂度）
}

// 失败类型
enum FailureType {
  EXPLOSION = 'explosion',       // 爆炸（温度过高）
  FREEZE = 'freeze',            // 冻结（温度过低）
  CONTAMINATION = 'contamination', // 污染（劣质原料）
  INSTABILITY = 'instability'   // 不稳定（配方过于复杂）
}

interface FailureResult {
  type: FailureType;
  message: string;
  coinLoss: number;              // 损失金币
  ingredientsLost: IngredientType[];  // 损失原料
  canRetry: boolean;             // 是否可重试
  insuranceCovered: boolean;     // 保险是否覆盖
}
```

---

#### 2. 核心算法

**颜色混合算法：**
```typescript
const mixColors = (color1: string, color2: string): string => {
  const colorMap: Record<string, [number, number, number]> = {
    '蓝色': [0, 0, 255],
    '红色': [255, 0, 0],
    '绿色': [0, 255, 0],
    // ...
  };
  
  const rgb1 = colorMap[color1];
  const rgb2 = colorMap[color2];
  const mixed = [
    (rgb1[0] + rgb2[0]) / 2,
    (rgb1[1] + rgb2[1]) / 2,
    (rgb1[2] + rgb2[2]) / 2
  ];
  
  // 映射回颜色名称
  return rgbToColorName(mixed);
};
```

**嵌套执行引擎：**
```typescript
const executeProgram = async (
  program: CodeBlock[], 
  state: PotionState
): Promise<ExecutionResult> => {
  for (const block of program) {
    if (block.type === 'REPEAT') {
      // 循环执行子指令
      for (let i = 0; i < block.value; i++) {
        await executeProgram(block.children!, state);
      }
    } else if (block.type.startsWith('IF_')) {
      // 条件判断
      if (evaluateCondition(block, state)) {
        await executeProgram(block.children!, state);
      }
    } else {
      // 基础指令
      applyIngredient(block, state);
      await animateEffect(block, state);
    }
  }
  
  return validateResult(state, targetConditions);
};
```

**条件判断系统：**
```typescript
const evaluateCondition = (
  block: CodeBlock, 
  state: PotionState
): boolean => {
  switch (block.type) {
    case 'IF_CONTAINS':
      return state.ingredients.includes(block.value as string);
    case 'IF_COLOR_IS':
      return state.color === block.value;
    case 'IF_TEMPERATURE':
      const [min, max] = block.value as [number, number];
      return state.temperature >= min && state.temperature <= max;
    // ...
  }
};
```

**💰 价格计算系统：**
```typescript
// 计算配方总成本
const calculateRecipeCost = (
  ingredients: IngredientInfo[],
  economy: EconomySystem
): number => {
  let totalCost = 0;
  
  for (const ingredient of ingredients) {
    // 基础价格 × 波动系数
    const fluctuation = economy.priceFluctuation.get(ingredient.type) || 1.0;
    const actualPrice = ingredient.currentPrice * fluctuation;
    totalCost += actualPrice;
  }
  
  return Math.round(totalCost);
};

// 计算期望收益（考虑成功率）
const calculateExpectedProfit = (
  cost: number,
  reward: number,
  successRate: number,
  insuranceCost: number = 0
): number => {
  const successProfit = reward - cost - insuranceCost;
  const failureLoss = -cost - insuranceCost;
  
  // 期望值公式：E = P(成功) × 成功收益 + P(失败) × 失败损失
  const expectedValue = 
    successRate * successProfit + 
    (1 - successRate) * failureLoss;
  
  return expectedValue;
};
```

**🎲 成功率计算系统：**
```typescript
// 综合成功率计算
const calculateSuccessRate = (
  ingredients: IngredientInfo[],
  state: PotionState
): number => {
  // 1. 原料品质影响 (劣质0.8, 普通1.0, 优质1.0)
  const qualityFactor = ingredients.reduce((acc, ing) => 
    acc * ing.successRate, 1.0);
  
  // 2. 温度控制影响 (理想范围50-70°C)
  const tempDeviation = Math.min(
    Math.abs(state.temperature - 50),
    Math.abs(state.temperature - 70)
  );
  const tempFactor = Math.max(0.5, 1 - tempDeviation * 0.01);
  
  // 3. 搅拌时机影响
  const stirFactor = state.isStirred ? 1.0 : 0.6;
  
  // 4. 配方复杂度影响
  const complexityFactor = Math.max(0.8, 1 - ingredients.length * 0.02);
  
  // 综合计算
  return Math.min(1.0, qualityFactor * tempFactor * stirFactor * complexityFactor);
};

// 成功率判定
const rollSuccessCheck = (successRate: number): boolean => {
  return Math.random() <= successRate;
};

// 失败处理
const handleFailure = (
  state: PotionState,
  economy: EconomySystem
): FailureResult => {
  let failureType: FailureType;
  
  if (state.temperature > 100) {
    failureType = FailureType.EXPLOSION;
  } else if (state.temperature < 0) {
    failureType = FailureType.FREEZE;
  } else {
    failureType = FailureType.INSTABILITY;
  }
  
  const actualLoss = economy.insurancePurchased 
    ? economy.currentOrderCost * 0.5 
    : economy.currentOrderCost;
  
  return {
    type: failureType,
    message: `失败！损失 ${actualLoss} 金币`,
    coinLoss: actualLoss,
    ingredientsLost: state.ingredients,
    canRetry: economy.coins >= actualLoss,
    insuranceCovered: economy.insurancePurchased
  };
};
```

---

#### 3. 关卡生成器升级

```typescript
export const generatePotionLevel = (levelId: number): PotionLevelConfig => {
  // 阶段 1 (关卡 1-3): 基础序列
  if (levelId <= 3) {
    return generateBasicSequenceLevel(levelId);
  }
  
  // 阶段 2 (关卡 4-6): 属性要求
  if (levelId <= 6) {
    return generateAttributeLevel(levelId);
  }
  
  // 阶段 3 (关卡 7-9): 循环
  if (levelId <= 9) {
    return generateLoopLevel(levelId);
  }
  
  // 阶段 4 (关卡 10-12): 条件
  if (levelId <= 12) {
    return generateConditionalLevel(levelId);
  }
  
  // 阶段 5 (关卡 13+): 综合
  return generateAdvancedLevel(levelId);
};

// 示例：生成循环关卡
const generateLoopLevel = (levelId: number): PotionLevelConfig => {
  const repeatCount = 2 + Math.floor(levelId / 3);
  const ingredient = pickRandom(['星尘', '熔岩', '草药']);
  
  return {
    id: levelId,
    title: `重复的力量 ${levelId - 6}`,
    description: `学会使用循环指令来简化代码`,
    customerRequest: `我需要一瓶浓缩药水，请加入${ingredient} ${repeatCount}次并每次都搅拌`,
    
    targetConditions: {
      // 验证逻辑：检查是否使用了循环，或者使用了正确数量的基础指令
    },
    
    constraints: {
      maxInstructions: repeatCount + 5  // 鼓励使用循环
    },
    
    availableBlocks: [
      'ADD_STARDUST', 'ADD_FLAME', 'ADD_HERB', 
      'STIR', 'REPEAT'  // 解锁循环指令
    ],
    
    unlockedConcepts: ['序列', '循环']
  };
};
```

---

### 六、成就与进度系统

**解锁机制：**
```
- 完成第3关 → 解锁"颜色大师"徽章
- 完成第6关 → 解锁"温度控制师"徽章
- 完成第9关 → 解锁"循环法师"徽章
- 完成第12关 → 解锁"条件专家"徽章
- 完成第15关 → 解锁"函数工程师"徽章
```

**统计面板：**
```
总关卡完成：15/20
最少指令挑战：8/15
完美配方：5/15
总药水制作：87瓶
```

**排行榜：**
- 最少指令排行
- 通关速度排行
- 完美配方数量排行

---

## 📊 改版前后对比

| 维度 | 改版前 | 改版后 |
|------|--------|--------|
| **编程概念** | 序列 | 序列、循环、条件、变量、函数 |
| **最大指令数** | 4条 | 30+条（嵌套结构）|
| **关卡上限** | ~10关后重复 | 可无限扩展（25+关卡）|
| **问题类型** | 记忆固定配方 | 开放式问题解决 + 策略决策 |
| **优化空间** | 无 | 多种解法，追求最优（成本/风险/速度）|
| **复杂度** | 1维（序列） | 5维（序列+状态+逻辑+经济+风险）|
| **决策维度** | 无 | 成本收益分析、风险评估、期望值计算 |
| **💰 经济系统** | 无 | 完整价格体系、利润优化、资源管理 |
| **🎲 风险系统** | 无 | 成功率机制、品质选择、保险系统 |
| **数学应用** | 无 | 加减法、百分比、概率、期望值 |
| **思维训练** | 序列思维 | 序列+抽象+决策+风险管理+优化思维 |
| **与真实编程** | 弱相关 | 强相关（算法+工程决策）|
| **与现实生活** | 无关联 | 强关联（资源管理、风险决策）|
| **训练效果** | 6/10 | 9.5/10 |

---

## 🎯 实施建议

### 分阶段实施（整合价格与成功率系统）

**Phase 1: 基础强化 + 💰价格系统原型（3周）**
- 实现属性系统（颜色、温度、魔力）
- **实现基础价格系统：**
  - 原料价格表
  - 金币计算逻辑
  - 成本/收益显示 UI
- 升级状态面板（增加经济状态）
- 重新设计关卡 1-6（引入价格概念）

**Phase 2: 循环引入 + 💰批量经济（2周）**
- 实现 REPEAT 指令
- 嵌套块 UI 组件
- **批量采购优化逻辑**
- 设计关卡 7-9（循环+成本优化）

**Phase 3: 条件逻辑 + 🎲成功率系统（4周）**
- 实现 IF 系列指令
- 条件评估引擎
- **实现成功率系统：**
  - 原料品质等级（劣质/普通/优质）
  - 成功率计算算法
  - 失败处理机制
  - 成功率预览 UI
- 设计关卡 10-12（条件+风险选择）

**Phase 4: 高级功能 + 🎲风险管理（3周）**
- 函数定义/调用
- **高级风险系统：**
  - 保险机制
  - 期望值计算
  - 风险决策辅助 UI
- 多顾客系统（资金池共享）
- 设计关卡 13-18（复合挑战）

**Phase 5: 经济模拟 + 综合挑战（3周）**
- **市场波动系统**（价格动态变化）
- **竞争模式**（与 NPC 对比）
- 批量订单策略分析
- 设计关卡 19-25（终极挑战）
- 成就系统（经济大师、风险专家等徽章）

**Phase 6: 打磨优化（2周）**
- 增强动画效果（金币飞溅、失败爆炸）
- 音效反馈（收益提示音、失败警报）
- 性能优化（复杂计算优化）
- 用户测试（特别关注儿童对价格和概率的理解）
- 平衡性调优（确保挑战性但不过度困难）

**总计：17周（约4个月）**

**优先级调整建议：**
- **MVP版本（8周）：** Phase 1-3（核心功能+价格+成功率基础）
- **完整版本（17周）：** 所有阶段
- **可选扩展：** 市场波动、竞争模式可作为后续更新

---

## ✅ 预期成果

改版后的魔法药水店将：

**编程思维层面：**
- ✅ **覆盖完整的编程基础概念**（序列、循环、条件、变量、函数）
- ✅ **培养真正的问题解决能力**（多维度思考、算法优化）
- ✅ **引入工程决策思维**（权衡取舍、多方案对比）

**数学与逻辑层面：**
- ✅ **💰 实用数学应用**（加减法、百分比、成本收益计算）
- ✅ **🎲 概率与统计入门**（成功率、期望值、风险评估）
- ✅ **优化思维训练**（在约束条件下寻找最优解）

**现实能力培养：**
- ✅ **💰 资源管理能力**（预算控制、利润最大化）
- ✅ **🎲 风险决策能力**（评估不确定性、平衡风险收益）
- ✅ **策略规划能力**（长期目标、批量优化）
- ✅ **经济意识启蒙**（成本概念、投资回报、保险价值）

**游戏体验层面：**
- ✅ **提供持续的挑战和成长空间**（25+关卡，多种难度）
- ✅ **保持游戏的趣味性和主题一致性**（魔法药水的真实感）
- ✅ **多样化的成就感来源**（完美配方、利润大师、风险专家）

**教育体系整合：**
- ✅ **与迷宫游戏形成互补**（迷宫=空间逻辑，药水店=数值决策）
- ✅ **跨学科融合**（编程+数学+经济学+逻辑学）

**最终目标：让孩子在制作魔法药水的过程中，不知不觉掌握编程思维、数学应用和现实决策能力！** 🎉

---

## 📝 附录：关键决策记录

### 为什么选择药水属性系统？
- 提供多维度思考（不只是序列）
- 引入状态管理概念（编程核心）
- 增加游戏深度和可玩性
- 符合魔法主题的自然扩展

### 为什么优先实现循环而非条件？
- 循环在儿童编程中更易理解（重复动作很直观）
- 可以立即看到代码简化的好处（6条变2条）
- 为后续条件判断打好基础

### 为什么需要函数抽象？
- 培养模块化思维
- 引入代码复用概念
- 为将来学习真实编程语言做准备
- 增加高级玩家的挑战性

### 💰 为什么引入价格体系？
**教育价值：**
- **实用数学应用：** 让抽象的加减法计算变得具体有意义
- **经济意识启蒙：** 从小培养成本概念和资源管理意识
- **优化思维训练：** 引入"最优解"概念，不只是"能完成"
- **决策能力培养：** 面对多种方案时，学会权衡利弊

**游戏设计理由：**
- 增加策略深度（不只是记配方，还要考虑成本）
- 提供多种解法（贵但稳定 vs 便宜但冒险）
- 创造长期目标（积累金币、解锁稀有原料）
- 符合真实世界逻辑（做生意要考虑成本）

**与编程的关联：**
- 算法优化：时间复杂度 ≈ 成本优化
- 工程决策：技术选型中的成本收益分析
- 资源管理：内存、CPU 等计算资源的优化

### 🎲 为什么引入成功率体系？
**教育价值：**
- **概率思维入门：** 理解"不确定性"和"期望值"概念
- **风险评估能力：** 学会评估风险和收益的平衡
- **科学决策方法：** 基于数据做决策，而非盲目冒险或过度保守
- **从失败中学习：** 失败不是终点，而是优化的起点

**游戏设计理由：**
- 增加紧张感和重玩性（即使同样操作，结果可能不同）
- 防止"完美策略"垄断（总有风险，需要动态调整）
- 创造戏剧性时刻（高风险成功的兴奋、意外失败的反思）
- 模拟真实世界（很多事情不是100%确定的）

**与编程的关联：**
- 软件测试：测试覆盖率 ≈ 成功率
- 容错设计：如何处理异常和失败情况
- 性能优化：在"快但不稳定"和"慢但可靠"之间权衡
- 生产环境决策：灰度发布、A/B测试的风险控制

**与现实生活的关联：**
- 投资理财（风险与收益）
- 保险决策（是否值得买保险）
- 职业选择（稳定 vs 高风险高回报）
- 日常决策（天气预报、交通路线选择）

### 为什么不过早引入？
**循序渐进原则：**
- 关卡 1-3：无价格/风险（新手保护，专注学习基础）
- 关卡 4-6：引入价格（一个维度，容易理解）
- 关卡 10+：引入成功率（有了基础后再加入不确定性）
- 关卡 19+：综合应用（价格+风险的复杂决策）

**认知负荷管理：**
- 避免同时引入太多新概念
- 让孩子先掌握确定性问题，再处理不确定性
- 每个阶段都有明确的学习目标

---

**文档版本：** v2.0 （新增价格体系和成功率体系）  
**创建日期：** 2026-01-14  
**作者：** CodeBanana AI  
**状态：** 设计方案 - 待实施